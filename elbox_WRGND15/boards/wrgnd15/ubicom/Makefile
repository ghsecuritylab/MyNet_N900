#############################################################################
# Makefile for UBICOM image
# Extracted from UBICOM32's SDK.
# Created by David Hsieh <david_hsieh@alphanetworks.com>
#############################################################################
-include ../path.mk
-include ../arch.mk
-include ultra.config

define MSG
echo -e "\033[$(if $(2),$(2),32)m$(1)\033[0m"
endef

BIN_DIR		:= bin
BUILDDIR	:= $(shell pwd)/build
ULTRA_TOOLS	:= build/tools
KERNEL_DIR	:= $(KERNELDIR)
LINUX_DIR	:= $(KERNELDIR)
UBOOT_DIR	:= build/u-boot
LOADER_DIR	:= build/gdbloader
BOOTEXEC_DIR:= build/bootexec
MAINEXEC_DIR:= build/mainexec

LZMA		:= $(TOPDIR)/tools/lzma/lzma
SEAMA		:= $(TOPDIR)/tools/seama/seama

SVNREV := $(shell svn info $(TOPDIR)/boards/$(ELBOX_BOARD_NAME)/ubicom | grep Revision: | cut -f2 -d' ')

export ALPHA_CONFIG_IPADDR=192.168.1.1

########################################################################
all:
	@$(call MSG,Please use: make {TARGET} - to build. Possible targets are:)
	@echo "     make ultra             - Bulid UBICOM's private code".
	@echo "     make ultra_clean       - Clean up UBICOM's private build".
	@echo "     make kernel_clean      - Clean up the kernel build."
	@echo "     make image_bootexec    - Create the ultra image."
	@echo "     make image_mainexec    - Create the ultra image."
	@echo "     make image_bootloader  - Build boot loader."
	@echo "     make image_uboot       - Build u-boot."
	@echo "     make image_distro      - Build distro."
	@echo "     make uboot             - Build boot loader [U-Boot]."
	@echo "     make clean             - Clean everything."
	@$(call MSG,Tools:)
	@echo "     make find_dongle       - Find UBICOM's dongle."
	@echo "     make uboot_install     - Update the U-Boot image via the dongle."
	@echo "     make distro_install    - Update the linux image via the dongle."
	@$(call,MSG,For main Makefile:)
	@echo "     make kernel_image      - Build the linux kernel/"

clean: ultra_clean uboot_clean image_clean
	$(Q)rm -rf $(BIN_DIR)

find_dongle:
	$(ULTRA_TOOLS)/udm4linux

.PHONY: all clean find_dongle
########################################################################
# This part is generating the kernel image.
KERNEL_CROSS	:= ubicom32-elf-
LINUX_KARCH		:= ubicom32
KERNELNAME		:=
KERNEL_MAKEOPTS	:= -C $(LINUX_DIR) CROSS_COMPILE="$(KERNEL_CROSS)" ARCH="$(LINUX_KARCH)" \
					KBUILD_HAVE_NLS=no CONFIG_SHELL="$(BASH)"
OBJCOPY_STRIP	:= -R .reginfo -R .note -R .comment -R .mdebug -R .note.gnu.build-id
KERNEL_BUILD_DIR:= $(shell pwd)/bin
LINUX_KERNEL	:= $(KERNEL_BUILD_DIR)/vmlinux

define Kernel/CompileImage
	$(Q)$(MAKE) $(KERNEL_MAKEOPTS) $(KERNELNAME)
	$(Q)$(KERNEL_CROSS)objcopy -O binary $(OBJCOPY_STRIP) -S $(LINUX_DIR)/vmlinux $(LINUX_KERNEL)
	$(Q)$(KERNEL_CROSS)objcopy $(OBJCOPY_STRIP) -S $(LINUX_DIR)/vmlinux $(KERNEL_BUILD_DIR)/vmlinux.elf
endef

kernel_image:
	$(Q)[ -d $(KERNEL_BUILD_DIR) ] || mkdir -p $(KERNEL_BUILD_DIR)
	$(Q)$(MAKE) $(KERNEL_MAKEOPTS) oldconfig
	$(Q)cp $(BOOTEXEC_DIR)/include/ocm_size.h $(KERNELDIR)/arch/ubicom32/include/asm/ocm_size.h
	$(Kernel/CompileImage)

kernel_clean:
	$(Q)make $(KERNEL_MAKEOPTS) mrproper

kernel:
	$(Kernel/CompileImage)

.PHONY: kernel_image kernel_clean kernel


########################################################################
# Include bootexec config.mk to get flash address settings
# The config.mk is generated by Ctool (UBICOM config tool).
# check_generate_config will call Ctool to generate the config file.
########################################################################
-include $(BOOTEXEC_DIR)/config/config.mk

#############################################################################
# Makefile.loader
OBJCOPY	:= ubicom32-elf-objcopy
OBJDUMP	:= ubicom32-elf-objdump
NM		:= ubicom32-elf-nm
ELF2BIN	:= $(BUILDDIR)/tools/elf2bin
# mkimage can also be found in a working u-boot build
#MKIMAGE:=$(UBOOT_DIR)/tools/mkimage
MKIMAGE	:= $(BUILDDIR)/tools/mkimage
GET_SECTOR_BOUNDARY := $(BUILDDIR)/scripts/get_sector_boundary.sh
PROG	:= expect $(BUILDDIR)/scripts/prog_board.exp ubicom32
export OBJCOPY OBJDUMP NM ELF2BIN GET_SECTOR_BOUNDARY PROG

define addGDBLoaderKernel
	@$(call MSG,... Adding GDB Loader Kernel to $(2)); \
	$(OBJCOPY) --add-section .downloader=$(LOADER_DIR)/loader.bin \
		--change-section-address=.downloader=0xd0000000 --set-section-flags \
		.downloader=contents,load $(1) $(2)
endef

define addImageToElf
	@ADDR=$(4);\
	echo -e "\033[32m";\
	echo "... Creating $(1) from $(2)";\
	echo "    with symbols $(3)";\
	echo "    loading at   `printf '0x%x' $$ADDR`";\
	echo -e "\033[0m";\
	$(OBJCOPY) --add-section .image=$(2) --change-section-address=.image=$$ADDR \
		--set-section-flags .image=contents,load $(3) $(1).tmp
	$(call addGDBLoaderKernel, $(1).tmp,$(1))
	rm $(1).tmp
endef

UPGRADE := $(BIN_DIR)/upgrade
########################################################################
# Final elf files
########################################################################
MAINEXEC_FINAL	:= $(BIN_DIR)/mainexec.elf
BOOTEXEC_FINAL	:= $(BIN_DIR)/bootexec.elf
UBOOT_FINAL		:= u-boot.elf # We will not build u-boot now.
DISTRO_FINAL	:= image.elf

########################################################################
# Check if parametered file exists
########################################################################
define CheckFile
	$(Q)if [ ! -e $(1) ]; then \
		$(call MSG,You need to build ULTRA first for missing file ($(1)).,31); \
		exit 1; \
	fi
endef

check_ocm_size_h:
	$(call CheckFile,$(BOOTEXEC_DIR)/include/ocm_size.h)

check_bootexec_ultra_elf:
	$(call CheckFile,$(BOOTEXEC_DIR)/ultra.elf)

check_mainexec_ultra_elf:
	$(call CheckFile,$(MAINEXEC_DIR)/ultra.elf)

check_loader_bin:
	$(call CheckFile,$(LOADER_DIR)/loader.bin)
	$(call CheckFile,$(LOADER_DIR)/lk.elf)

check_bootexec_config_mk:
	$(call CheckFile,$(BOOTEXEC_DIR)/config/config.mk)

check_bootexec_bd_bin:
	$(call CheckFile,$(BOOTEXEC_DIR)/bd.bin)

check_bin_dir:
	@if [ ! -e $(BIN_DIR) ]; then mkdir -p $(BIN_DIR); fi

check_rootfs_img:
	$(Q)if [ ! -e $(BIN_DIR)/rootfs.img ]; then \
		$(call MSG,You need to build the rootfs image file first.,31); exit 1; fi

########################################################################
# Clean produced elf files
########################################################################
image_clean:
	@$(call MSG,Cleaning all images ...)
	$(Q)rm -f $(UBOOT_FINAL)
	$(Q)rm -f $(DISTRO_FINAL)
	$(Q)rm -f $(BIN_DIR)/*

########################################################################
# Flash address settings. These settings are received from ctool
########################################################################
mainexec_flash_begin_addr:= 0x`${NM} $(MAINEXEC_FINAL) | grep __flash_begin | sed 's/ .*//'`
bootexec_flash_begin_addr:= 0x`${NM} $(BOOTEXEC_FINAL) | grep __flash_begin | sed 's/ .*//'`
#mainexec_flash_limit_addr:= 0x`${NM} $(MAINEXEC_FINAL) | grep __flash_limit | sed 's/ .*//'`
mainexec_sdram_begin_addr:= 0x`${NM} $(MAINEXEC_FINAL) | grep __sdram_begin | sed 's/ .*//'`

flash_sector_size:=$$(( $(EXTFLASH_MAX_PAGE_SIZE_KB) * 1024 ))
flash_sector_mask:=$$(( $(flash_sector_size) - 1 ))
bootloader_reserved_space:= $(APP_BOOTLOADER_RESERVED_SPACE_IN_SECTORS) * $(flash_sector_size)
#bootexec_image_end_addr_from_elf := `$(SHELL) $(GET_SECTOR_BOUNDARY) $(BOOTEXEC_FINAL) 1`

ifdef CONFIG_DISABLE_MAINEXEC
bootexec_sdram_begin_addr:= 0x`${NM} $(BOOTEXEC_FINAL) | grep __sdram_begin | sed 's/ .*//'`
uClinux_image_start_addr_dec := $$(($(bootexec_flash_begin_addr) + $(bootloader_reserved_space)))
uClinux_image_run_addr_dec := $$(($(bootexec_sdram_begin_addr) + $(APP_UCLINUX_MEM_START_ADDR)))
else
uClinux_image_start_addr_dec := $$(($(mainexec_flash_begin_addr) + $(bootloader_reserved_space)))
uClinux_image_run_addr_dec := $$(($(mainexec_sdram_begin_addr) + $(APP_UCLINUX_MEM_START_ADDR)))
endif

########################################################################
# If u-boot is enabled, the start of distro linux will change
########################################################################
ifeq ($(CONFIG_LOADER_UBOOT),y)

bootexec_flash_begin_addr:= 0x`${NM} $(BOOTEXEC_FINAL) | grep __flash_begin | sed 's/ .*//'`
bootexec_flash_limit_addr:= 0x`${NM} $(BOOTEXEC_FINAL) | grep __flash_limit | sed 's/ .*//'`
ULTRA_UBOOT_CONFIG_H := $(UBOOT_DIR)/include/configs/ultra_uboot_config.h
uboot_env_size := $$(($(APP_UBOOT_ENV_SIZE_IN_SECTORS) * $(EXTFLASH_MAX_PAGE_SIZE_KB) * 1024))
uboot_env_addr := $$(($(bootexec_flash_limit_addr) - $(uboot_env_size)))
uboot_image_last_sector := $(APP_BOOTLOADER_RESERVED_SPACE_IN_SECTORS)
uboot_image_end_addr_from_elf := `$(SHELL) $(GET_SECTOR_BOUNDARY) $(UBOOT_FINAL) 1`
uboot_image_end_addr := $$(($(bootexec_flash_begin_addr) + $(bootloader_reserved_space) - $(APP_SNV_RESERVED_KB) * 1024))

endif

########################################################################
# Targets for mainexec. We have mainexec elf file after typing make mainexec.
# Therefore, here we only check if it exists.
########################################################################
image_mainexec: $(MAINEXEC_FINAL)
image_bootexec: $(BOOTEXEC_FINAL)
image_bootloader: $(BOOTEXEC_FINAL)
ifeq ($(CONFIG_LOADER_UBOOT),y)
image_bootloader: $(UBOOT_FINAL)
endif

########################################################################
# Targets for distro. Before producing distro image, images it depends on
# must be ready. These are bootexec and u-boot if enabled. Before creating
# new distro elf file, we remove old vmlinux related binaries.
########################################################################
image_distro: image_distro_clean $(DISTRO_FINAL)
image_distro_clean:
	$(Q)rm -f $(DISTRO_FINAL) $(UPGRADE).* $(BIN_DIR)/vmlinux.bin

distro_install install_distro:
ifneq ($(strip $(UBICOM_DONGLE)),)
	$(Q)$(PROG) $(DISTRO_FINAL)
else
	$(Q)$(call MSG,CAN NOT found variable - UBICOM_DONGLE !!,31)
	$(Q)$(call MSG,Please export UBICOM_DONGLE=x.x.x.x:5010 .,31)
endif

.PHONY: image_distro image_distro_clean install_distro distro_install

$(DISTRO_FINAL): $(UPGRADE).elf
	$(Q)ln -sfv $< $@
	@echo
	@echo -e "\033[32mRun 'ubicom32-elf-gdb $@' to load using dongle or\033[0m"
	@echo -e "\033[32m$(UPGRADE).ub to upgrade with u-boot.\033[0m"

########################################################################
# Align the start of the vmlinux.elf image to the next sector boundary
# after the bootexec end and u-boot if enabled. Otherwise, vmlinux would
# overwrite the it.
########################################################################

FWDEV   := /dev/mtdblock/1
$(UPGRADE).elf: $(UPGRADE).ub
	$(Q)$(SEAMA) -i $(UPGRADE).ub\
		   -m dev=$(FWDEV) -m type=firmware -m signature=$(ELBOX_SIGNATURE) -m noheader=0
	$(call addImageToElf,$@,$(UPGRADE).ub.seama,$(KERNEL_DIR)/vmlinux,$(uClinux_image_start_addr_dec));

#$(ROOTFS).bin: $(SQUASHFS_IMAGE_FILE)
#	cp $< $@

#$(ROOTFS).elf: $(ROOTFS).bin
#	$(call addImageToElf,$@,$<,$(LOADER_DIR)/lk.elf,0x60200000);

#
# The multi image is setup as follows:
#   Image 0: Mainexec
#   Image 1: Initial ramdisk
#   Image 2: Linux Kernel
#
# Even if the initial ramdisk is not used, you must have a dummy image in
# the image 1 slot.
#
# The entry point is the same for mainexec and linux kernel.
#
ifdef CONFIG_WITH_LZMA

ifdef CONFIG_DISABLE_MAINEXEC
IMAGE_LIST			:= $(BIN_DIR)/vmlinux.lzma $(BIN_DIR)/rootfs.img
IMAGE_LIST_MKIMAGE	:= $(BIN_DIR)/vmlinux.lzma:$(BIN_DIR)/rootfs.img
else
IMAGE_LIST			:= $(BIN_DIR)/mainexec.lzma $(BIN_DIR)/rootfs.img $(BIN_DIR)/vmlinux.lzma
IMAGE_LIST_MKIMAGE	:= $(BIN_DIR)/mainexec.lzma:$(BIN_DIR)/rootfs.img:$(BIN_DIR)/vmlinux.lzma
endif

$(UPGRADE).ub: $(IMAGE_LIST) $(UPGRADE).vars
	$(Q). $(UPGRADE).vars; \
	$(call MSG,... Creating u-boot image $@ from $<); \
	$(MKIMAGE) -A ubicom32 -O linux -T multi -C lzma -a $$START_ADDR -e $$ENTRY_POINT \
		-n $(CONFIG_IDENTITY_STRING) -d $(IMAGE_LIST_MKIMAGE) $@;
	@$(call MSG,Sector Size is $(flash_sector_size))
	$(Q)EXTRA=$$(($(flash_sector_size) - (`stat $@ -c %s` & $(flash_sector_mask)))); \
	$(call MSG,Add $$EXTRA bytes to $@ to round up to $(flash_sector_size) byte boundary); \
	dd oflag=append of=$@ if=/dev/zero conv=block,notrunc count=$$EXTRA bs=1 status=noxfer 2> /dev/null

$(BIN_DIR)/rootfs.img: check_rootfs_img

$(BIN_DIR)/vmlinux.lzma: $(BIN_DIR)/vmlinux.bin
	@$(call MSG,... Creating $@ from $<)
	$(Q)$(LZMA) -c $< > $@

$(BIN_DIR)/mainexec.lzma: $(BIN_DIR)/mainexec.bin
	@$(call MSG,... Creating $@ from $<)
	$(Q)$(LZMA) -c $< > $@

$(LZMA):
	$(Q)make -C $(TOPDIR)/tools/lzma

else	# ifdef CONFIG_WITH_LZMA

ifdef CONFIG_DISABLE_MAINEXEC
IMAGE_LIST			:= $(BIN_DIR)/vmlinux.gz $(BIN_DIR)/rootfs.img
IMAGE_LIST_MKIMAGE	:= $(BIN_DIR)/vmlinux.gz:$(BIN_DIR)/rootfs.img
else
IMAGE_LIST			:= $(BIN_DIR)/mainexec.gz $(BIN_DIR)/rootfs.img $(BIN_DIR)/vmlinux.gz
IMAGE_LIST_MKIMAGE	:= $(BIN_DIR)/mainexec.gz:$(BIN_DIR)/rootfs.img:$(BIN_DIR)/vmlinux.gz
endif

$(UPGRADE).ub: $(IMAGE_LIST) $(UPGRADE).vars
	$(Q). $(UPGRADE).vars; \
	$(call MSG,... Creating u-boot image $@ from $<); \
	$(MKIMAGE) -A ubicom32 -O linux -T multi -C gzip -a $$START_ADDR -e $$ENTRY_POINT \
		-n $(CONFIG_IDENTITY_STRING) -d $(IMAGE_LIST_MKIMAGE) $@;
	@$(call MSG,Sector Size is $(flash_sector_size))
	$(Q)EXTRA=$$(($(flash_sector_size) - (`stat $@ -c %s` & $(flash_sector_mask)))); \
	$(call MSG,Add $$EXTRA bytes to $@ to round up to $(flash_sector_size) byte boundary); \
	dd oflag=append of=$@ if=/dev/zero conv=block,notrunc count=$$EXTRA bs=1 status=noxfer 2> /dev/null

$(BIN_DIR)/rootfs.img: check_rootfs_img

$(BIN_DIR)/vmlinux.gz: $(BIN_DIR)/vmlinux.bin
	@$(call MSG,... Creating $@ from $<)
	$(Q)cat $< | gzip -v -9 > $@

$(BIN_DIR)/mainexec.gz: $(BIN_DIR)/mainexec.bin
	@$(call MSG,... Creating $@ from $<)
	$(Q)cat $< | gzip -v -9 > $@

endif	#ifdef CONFIG_WITH_LZMA

$(UPGRADE).vars: $(BIN_DIR)/vmlinux.bin
	$(Q)printf "START_ADDR=0x%x\n" $$(( $(uClinux_image_run_addr_dec))) > $@
	$(Q)printf "ENTRY_POINT=0x%x\n" $$(( $(uClinux_image_run_addr_dec))) >> $@

#
# TODO: if you want an initial ramdisk then here is the place to put it
# today we put a dummy file
#
$(BIN_DIR)/initrd.bin:
	$(Q)touch $@

$(BIN_DIR)/vmlinux.bin:
	@$(call MSG,... Extracting $@ from $(KERNEL_DIR)/vmlinux)
	$(Q)$(ELF2BIN) -b _begin -e _end -f 0xff -pad $(KERNEL_DIR)/vmlinux -o $@

$(BIN_DIR)/mainexec.bin: $(BIN_DIR)/mainexec.elf
	@$(call MSG,... Extracting $@ from $<)
	$(Q)$(ELF2BIN) -b __flash_entry_load_begin -e __flash_limit -f 0xff $< -o $@

$(MAINEXEC_DIR)/ultra.elf: check_mainexec_ultra_elf
$(MAINEXEC_FINAL): $(MAINEXEC_DIR)/ultra.elf check_bin_dir
	$(Q)cp $(MAINEXEC_DIR)/ultra.elf $@

$(BOOTEXEC_DIR)/ultra.elf: check_bootexec_ultra_elf
$(BOOTEXEC_FINAL): $(BOOTEXEC_DIR)/ultra.elf check_bin_dir
	$(call addGDBLoaderKernel,$<,$@)

########################################################################
# Prepare u-boot image and load it
########################################################################
ifeq ($(CONFIG_LOADER_UBOOT),y)

image_uboot: image_uboot_clean check_bin_dir $(UBOOT_FINAL) check_uboot_size
image_uboot_clean:
	@$(call MSG,Cleaning u-boot images ...)
	$(Q)rm -f $(UBOOT_FINAL) $(BIN_DIR)/u-boot* $(BIN_DIR)/bootexec_bd.*

$(UBOOT_FINAL): $(BIN_DIR)/u-boot.elf
	$(Q)ln -sfv $< $@

$(BIN_DIR)/u-boot.elf: $(BIN_DIR)/bootexec_bd.bin+u-boot.ub $(BOOTEXEC_FINAL)
	$(call addImageToElf,$@,$<,$(UBOOT_DIR)/u-boot,$(bootexec_flash_begin_addr))

$(BIN_DIR)/bootexec_bd.bin+u-boot.ub: $(BIN_DIR)/u-boot.ub check_bootexec_bd_bin
	$(Q)cp $(BOOTEXEC_DIR)/bd.bin $(BIN_DIR)/bootexec_bd.bin
	$(Q)cp $(BIN_DIR)/bootexec_bd.bin $@
	$(Q)EXTRA=$$(((`stat $@ -c %s` & 31) ? (32 - (`stat $@ -c %s` & 31)) : 0)); \
	echo "Add $$EXTRA bytes to bootexec_bd.bin to round up to 32 byte boundary"; \
	dd oflag=append of=$@ if=/dev/zero conv=block,notrunc count=$$EXTRA bs=1 status=noxfer 2> /dev/null
	@$(call MSG,Padded bootexec_bd.bin size `stat $@ -c %s`)
	$(Q)cat $< >> $@
	@$(call MSG,New size `stat $@ -c %s`)

$(BIN_DIR)/u-boot.ub: $(BIN_DIR)/u-boot.gz $(BIN_DIR)/u-boot.vars
	@$(call MSG,... Creating u-boot image $@ from $<)
	$(Q). $(BIN_DIR)/u-boot.vars; \
	$(MKIMAGE) -A ubicom32 -O u-boot -T firmware -C gzip \
				-a $$START_ADDR -e $$ENTRY_POINT \
				-n "$(CONFIG_IDENTITY_STRING) SVN revision: $(SVNREV)" -d $< $@;

$(BIN_DIR)/u-boot.vars: $(BIN_DIR)/u-boot.bin
	@$(call MSG,Creating $(BIN_DIR)/u-boot.vars ...)
	$(Q)UBOOT_ADDR=0x`${NM} $(UBOOT_DIR)/u-boot | grep _stext | sed 's/ .*//'`; \
	echo "START_ADDR=$$UBOOT_ADDR" > $@; \
	echo "ENTRY_POINT=$$UBOOT_ADDR" >> $@

$(BIN_DIR)/u-boot.gz: $(BIN_DIR)/u-boot.bin
	@$(call MSG,... Creating $@ from $<)
	@$(call MSG,    compressing with gzip...)
	$(Q)gzip -v < $<  > $@

$(BIN_DIR)/u-boot.bin:
	@$(call MSG,... Extracting $@ from $(UBOOT_DIR)/u-boot)
	$(Q)$(ELF2BIN) -b _stext -e _end -f 0xff -pad $(UBOOT_DIR)/u-boot -o $@

check_uboot_size:
	@$(call MSG,Checking if u-boot image size fits into the reserved space in flash...)
	$(Q)if [ $(uboot_image_end_addr) -lt $(uboot_image_end_addr_from_elf) ]; then \
		echo -e "\033[31m"; \
		echo "** u-boot image size is bigger than its reserved space in flash, can't continue."; \
		echo "** u-boot image size end address is $(uboot_image_end_addr_from_elf)."; \
		echo "** Reserved space for u-boot image ends at $(uboot_image_end_addr)."; \
		echo -e "\033[0m"; \
		exit 1; \
	fi

uboot_install install_uboot:
ifneq ($(strip $(UBICOM_DONGLE)),)
	$(PROG) $(UBOOT_FINAL)
else
	$(Q)$(call MSG,CAN NOT found variable - UBICOM_DONGLE !!,31)
	$(Q)$(call MSG,Please export UBICOM_DONGLE=x.x.x.x:5010 .,31)
endif

endif

#############################################################################
# Compile u-boot
#############################################################################

ifeq ($(CONFIG_LOADER_UBOOT),y)

uboot: ultra recursive_uboot
	@echo "#define ALPHA_CONFIG_IPADDR \"$$ALPHA_CONFIG_IPADDR\"" >> build/u-boot/include/config.h

recursive_uboot:
	$(Q)make -f Makefile recursive_uboot_do

recursive_uboot_do: check_ultra_uboot_config_h check_uboot_config uboot_all image_uboot
uboot_%:
	@$(call MSG,Building U-Boot $(patsubst uboot_%,%,$@))
	$(Q)make -s -C $(UBOOT_DIR) $(patsubst uboot_%,%,$@)
#fix by siyou, which will make ssh terminal fail.
#	 $(Q)make -s -C $(UBOOT_DIR) $(patsubst uboot_%,%,$@) $(if $(Q),> /dev/null,)

check_ultra_uboot_config_h: $(ULTRA_UBOOT_CONFIG_H)
	@uClinux_image_start_addr_dec=$(uClinux_image_start_addr_dec); \
	uClinux_image_start_addr_hex=0x`echo "obase=16; ibase=10; " $$uClinux_image_start_addr_dec | bc`; \
	uClinux_image_run_addr_dec=$(uClinux_image_run_addr_dec); \
	uClinux_image_run_addr_hex=0x`echo "obase=16; ibase=10; " $$uClinux_image_run_addr_dec | bc`; \
	awk -v new_config_env_addr=$(uboot_env_addr) \
		-v new_config_uboot_image_last_sector=$(uboot_image_last_sector) \
		-v new_config_uboot_mem_size=$$(($(APP_UBOOT_MEM_SIZE))) \
		-v new_config_uClinux_image_start_addr=$$uClinux_image_start_addr_hex \
		-v new_config_uClinux_mem_start_addr=$$uClinux_image_run_addr_hex \
		-v new_config_env_size=$(uboot_env_size) ' \
		BEGIN { \
			old_config_env_addr = old_config_env_size = old_config_uboot_mem_size = old_config_uboot_image_last_sector =-1; \
			old_config_uClinux_image_start_addr = old_config_uClinux_mem_start_addr = -1; \
		} \
		/CONFIG_ENV_ADDR/   { old_config_env_addr = $$3 } \
		/CONFIG_ENV_SIZE/   { old_config_env_size = $$3 } \
		/CONFIG_UBOOT_MEM_SIZE/ { old_config_uboot_mem_size = $$3 } \
		/CONFIG_UBOOT_IMAGE_LAST_SECTOR/ { old_config_uboot_image_last_sector = $$3 } \
		/CONFIG_UCLINUX_IMAGE_START_ADDR/ { old_config_uClinux_image_start_addr = $$3 } \
		/CONFIG_UCLINUX_MEM_START_ADDR/ { old_config_uClinux_mem_start_addr = $$3 } \
		END { \
			if ((new_config_env_addr != old_config_env_addr) || \
				(new_config_env_size != old_config_env_size) || \
				(new_config_uboot_mem_size != old_config_uboot_mem_size) || \
				(new_config_uClinux_image_start_addr != old_config_uClinux_image_start_addr) || \
				(new_config_uClinux_mem_start_addr != old_config_uClinux_mem_start_addr) || \
				(new_config_uboot_image_last_sector != old_config_uboot_image_last_sector)) { \
				print "#define CONFIG_ENV_ADDR ", new_config_env_addr >  "$<"; \
				print "#define CONFIG_ENV_SIZE ", new_config_env_size >> "$<"; \
				print "#define CONFIG_UBOOT_MEM_SIZE ", new_config_uboot_mem_size >> "$<"; \
				print "#define CONFIG_UBOOT_IMAGE_LAST_SECTOR ", new_config_uboot_image_last_sector >> "$<"; \
				print "#define CONFIG_UCLINUX_IMAGE_START_ADDR ", new_config_uClinux_image_start_addr >> "$<"; \
				print "#define CONFIG_UCLINUX_MEM_START_ADDR ", new_config_uClinux_mem_start_addr >> "$<"; \
			} \
		}' $<

$(ULTRA_UBOOT_CONFIG_H): check_bootexec_config_mk $(BOOTEXEC_FINAL) $(MAINEXEC_FINAL)
	$(Q)if [ ! -f $@ ]; then \
		$(call MSG,Generating $(ULTRA_UBOOT_CONFIG_H) ...); \
		uClinux_image_start_addr_dec=$(uClinux_image_start_addr_dec); \
		uClinux_image_start_addr_hex=0x`echo "obase=16; ibase=10; " $$uClinux_image_start_addr_dec | bc`; \
		uClinux_image_run_addr_dec=$(uClinux_image_run_addr_dec); \
		uClinux_image_run_addr_hex=0x`echo "obase=16; ibase=10; " $$uClinux_image_run_addr_dec | bc`; \
		echo "#define CONFIG_ENV_ADDR					$(uboot_env_addr)" > $@; \
		echo "#define CONFIG_ENV_SIZE					$(uboot_env_size)" >> $@; \
		echo "#define CONFIG_UBOOT_MEM_SIZE				$(APP_UBOOT_MEM_SIZE)" >> $@; \
		echo "#define CONFIG_UBOOT_IMAGE_LAST_SECTOR	$(uboot_image_last_sector)" >> $@; \
		echo "#define CONFIG_UCLINUX_IMAGE_START_ADDR	" $$uClinux_image_start_addr_hex >> $@; \
		echo "#define CONFIG_UCLINUX_MEM_START_ADDR		" $$uClinux_image_run_addr_hex >> $@; \
	fi

check_uboot_config: $(ULTRA_UBOOT_CONFIG_H) $(UBOOT_DIR)/include/config.mk
	@$(call MSG,Board is $(AP_BOARD_NAME))
	$(Q)awk '/BOARD/ { \
		if ($$3 != "$(AP_BOARD_NAME)") { \
			system("make -C $(UBOOT_DIR) distclean"); \
			system("make -C $(UBOOT_DIR) $(AP_BOARD_NAME)_config"); \
		} \
	}' $(UBOOT_DIR)/include/config.mk

$(UBOOT_DIR)/include/config.mk:
	@$(call MSG,Generate $(UBOOT_DIR)/include/config.mk - $(AP_BOARD_NAME)_config)
	$(Q)make -C $(UBOOT_DIR) $(AP_BOARD_NAME)_config

endif

#############################################################################
# Ubicom-private contains the private code of UBICOM.
# DO NOT include this folder for GPL release.
#############################################################################
ifneq ($(wildcard ubicom-private),)
ultra:
	@$(call MSG,Building ULTRA ...)
	@make -C ubicom-private V=$(V) DEBUG=$(DEBUG)

ultra_clean:
	@$(call MSG,Cleaning ULTRA ...)
	@make -C ubicom-private install_clean V=$(V) DEBUG=$(DEBUG)
	@make -C ubicom-private clean  V=$(V) DEBUG=$(DEBUG)
else
ultra: check_ocm_size_h check_bootexec_ultra_elf check_mainexec_ultra_elf
ultra_clean:
endif
.PHONY: ultra ultra_clean
#############################################################################
